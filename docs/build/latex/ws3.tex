%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage[dontkeepoldnames]{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{ws3 Documentation}
\date{Jan 04, 2018}
\release{0.1a1}
\author{Gregory Paradis}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{Overview}
\label{\detokenize{intro:ws3-package-documentation}}\label{\detokenize{intro:overview}}\label{\detokenize{intro::doc}}
This chapter describes the \sphinxcode{ws3} Python software package. \sphinxcode{ws3} (short for \sphinxstyleemphasis{Wood Supply Simulation System}) is an open-source software package that is designed to model \sphinxstyleemphasis{wood supply planning problems} (WSPP), in the context of sustainable forest management.


\section{Background}
\label{\detokenize{intro:background}}
The WSPP basically consists of determining the location, nature, and timing of forest managment activities (i.e., \sphinxstyleemphasis{actions}) for a given forest, typically over multiple planning periods (often spanning a planning horizon of 100 years or more). This is a very complex problem, so in practice the WSPP process is typically supported by complex software models that simulate an alternating sequence of \sphinxstyleemphasis{actions} and \sphinxstyleemphasis{growth} for each time step, starting from an initial forest inventory.

Wood supply models require complex input datasets. WSM input data can be divided into \sphinxstyleemphasis{static} and \sphinxstyleemphasis{dynamic} components.

Static WSM input data types include initial forest inventory, growth and yield curves, action definitions, transition definitions, and a schedule of prescribed activities to simulate.
Dynamic WSM input data may include a combination of heuristic and optimization-based processes to automatically derive a dynamic activity schedule (which gets layered on top of the static activity schedule).

The forest inventory data is typically aggregated into a manageable number of \sphinxstyleemphasis{strata} (i.e., \sphinxstyleemphasis{development types}), which simplifies the modelling.  Each development type is linked to \sphinxstyleemphasis{growth and yield} functions describing the change in key attributes attributes (e.g., species-wise standing timber volume, number of merchantable stems per unit area, wildlife habitat suitability index value, etc.) expressed as a function of statum age. Each development type may also be associated with one or more \sphinxstyleemphasis{actions}, which can yield \sphinxstyleemphasis{output products} (e.g., species-wise assortments of raw timber products, cost, treated area, etc.). Applying an action to a development type induces a \sphinxstyleemphasis{state transition} (i.e., applying an action may modify one or more stratification variables, effectively transitioning the treated area to a different development type).

Given a set of static inputs, a given WSM can be used to simulate a number of \sphinxstyleemphasis{scenarios}. Generally, scenarios differ only in terms of the dynamic activity schedule that is simulated. Comparing output from several scenarios is the basic mechanism by which forest managers derive insight from wood supply models.

There are two basic approached that can be used (independently, or in combination) to generate the dynamic activity schedules for each scenario.

The simplest approach, which we call the \sphinxstyleemphasis{heuristic} activity scheduling method, involves defining period-wise targets for a single key output (e.g., total harvest volume) along with a set of rules that determines the order in which actions are applied to eligible development types. At each time step, the model iteratively applies actions according to the rules until the output target value is met, or it runs out of eligible area. At this point, the model simulates one time-step worth of growth, and the process repeats until the end of the planning horizon.

A slightly more complex approach, which we call the \sphinxstyleemphasis{optimization} activity scheduling method, involves defining an optimization problem (i.e., an objective function and constraints), and solving this problem to optimality (using one of several available third-party mathematical solver software packages).

Although the optimization approach is more powerful than the heuristic approach for modelling harvesting and other anthopic activites, an optimization approach is not appropriate for modelling strongly-stochastic disturbance processes (e.g., wildfire, insect invasions, blowdown). Thus, a hybrid heuristic-optimization approach may be best when modelling a combination of anthopic and natural disturbance processes.


\section{Package Design and Implementation}
\label{\detokenize{intro:package-design-and-implementation}}
The \sphinxcode{ws3} package is implemented using the Python programming language. \sphinxcode{ws3} is basically an aspatial wood supply model, which applies actions to development types, simulates growth, and tracks inventory area at each time step. Aspatial models output aspatial activity schedules—each line of the output schedule specifies the stratification variable values (which constitute a unique key into the list of development types), the time step, the action code, and the area treated.

Because the model is aspatial, the area treated on a given line of the output schedule may not be spatially contiguous (i.e., the area may be geographically dispersed throughout the landscape). Furthermore, in the common case where only a subset of development type area is treated in a given time step, the aspatial model provides not information regarding which subset of available area is treated (and, conversely, not treated). Some applications (e.g., linking to spatially-explicit or highly\textendash{}spatially-referenced models) require a spatially-explicit activity schedule. \sphinxcode{ws3} includes a \sphinxstyleemphasis{spatial disturbance allocator} sub-module, which contains functions that can map aspatial multi-period action schedules onto a rasterized spatial representation of the forest.

\sphinxcode{ws3} uses a scripted Python interface to control the model, which provides maximum flexibility and makes it very easy to automate modelling workflows. This ensures reproducible methodologies, and makes it relatively easy to link \sphinxcode{ws3} models to other software packages to form complex modelling pipelines. The scripted interface also makes it relatively easy to implement custom data-importing functions, which makes it easier to import existing data from a variety of ad-hoc sources without the need to recompile the data into a standard \sphinxcode{ws3}-specific format (i.e., importing functions can be implemented such that the conversion process is fully automated and applied to raw input data \sphinxstyleemphasis{on the fly}). Similarly, users can easily implment custom functions to re-format \sphinxcode{ws3} output data \sphinxstyleemphasis{on the fly} (either for static serialization to disk, or to be piped live into another process).

Although we recommend using Jupyter Notebooks as an interactive interface to \sphinxcode{ws3} (the package was specifically designed with an interactive notebook interface in mind), \sphinxcode{ws3} functions can also be imported and run in fully scripted workflow (e.g., non-interactive batch processes can be run in a massively-parallelled workflow on high-performance\textendash{}computing resources, if available). The ability to mix interactive and massively-paralleled non-interactive workflows is a unique feature of \sphinxcode{ws3}.

\sphinxcode{ws3} is a complex and flexible collection of functional software units. The following sections describe some of the main classes and functions in the package, and describe some common use cases, and link to sample notebooks that implement these use cases.


\section{Overview of Main Classes and Functions}
\label{\detokenize{intro:overview-of-main-classes-and-functions}}
This section describes some of the main classes and functions that make up.

The \sphinxcode{ForestModel} class is the core class in the package. This class encapsulates all the information used to simulate scenarios from a given dataset (i.e., stratified intial inventory, growth and yield functions, action eligibility, transition matrix, action schedule, etc.), as well as a large collection of functions to import and export data, generate activity schedules, and simulate application of these schedules  (i.e., run scenarios).

At the heart of the \sphinxcode{ForestModel} class is a list of \sphinxcode{DevelopentType} instances. Each \sphinxcode{DevelopmentType} instance encapsulates information about one development type (i.e., a forest stratum, which is an aggregate of smaller \sphinxstyleemphasis{stands} that make up the raw forest inventory input data). The \sphinxcode{DevelopmentType} class also stores a list of operable \sphinxstyleemphasis{actions}, maps \sphinxstyleemphasis{state variable transitions} to these actions, stores growth and yield functions, and knows how to \sphinxstyleemphasis{grow itself} when time is incremented during a simulation.


\section{Common Use Case and Sample Notebooks}
\label{\detokenize{intro:common-use-case-and-sample-notebooks}}
In this section, we assume an interactive Jupyter Notebook environment is used to interface with \sphinxcode{ws3}.

A typical use case starts with creating an instance of the \sphinxcode{ForestModel} class. Then, we need to load data into this instance, define one or more scenarios (using a mix of heuristic and optimization approaches), run the scenarios, and export output data to a format suitable for analysis (or link to the next model in a larger modelling pipeline).

The first step in typical workflow is to run a mix of standard \sphinxcode{ws3} and custom data-importing functions.  These functions import data from various sources, \sphinxstyleemphasis{on-the-fly} reformat this data to be compatible with \sphinxcode{ws3}, and load the reformated data into the \sphinxcode{ForestModel} instance using standard methods. For example, \sphinxcode{ws3} includes functions to import legacy Woodstock %
\begin{footnote}[1]\sphinxAtStartFootnote
Woodstock software is part of \sphinxhref{http://www.remsoft.com/forestry.php}{Remsoft Solution Suite}.
%
\end{footnote} model data (including LANDSCAPE, CONSTANTS, AREAS, YIELDS, LIFESPAN, ACTIONS, TRANSITIONS, and SCHEDULE section data), as well as functions to import and rasterize vector stand inventory data.

For example, one might define the following custom Python function in a Jupyter Notebook, to import data formatted for Woodstock.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{instantiate\PYGZus{}forestmodel}\PYG{p}{(}\PYG{n}{model\PYGZus{}name}\PYG{p}{,} \PYG{n}{model\PYGZus{}path}\PYG{p}{,} \PYG{n}{horizon}\PYG{p}{,}
                            \PYG{n}{period\PYGZus{}length}\PYG{p}{,} \PYG{n}{max\PYGZus{}age}\PYG{p}{,} \PYG{n}{add\PYGZus{}null\PYGZus{}action}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{fm} \PYG{o}{=} \PYG{n}{ForestModel}\PYG{p}{(}\PYG{n}{model\PYGZus{}name}\PYG{o}{=}\PYG{n}{model\PYGZus{}name}\PYG{p}{,}
                     \PYG{n}{model\PYGZus{}path}\PYG{o}{=}\PYG{n}{model\PYGZus{}path}\PYG{p}{,}
                     \PYG{n}{horizon}\PYG{o}{=}\PYG{n}{horizon}\PYG{p}{,}
                     \PYG{n}{period\PYGZus{}length}\PYG{o}{=}\PYG{n}{period\PYGZus{}length}\PYG{p}{,}
                     \PYG{n}{max\PYGZus{}age}\PYG{o}{=}\PYG{n}{max\PYGZus{}age}\PYG{p}{)}
    \PYG{n}{fm}\PYG{o}{.}\PYG{n}{import\PYGZus{}landscape\PYGZus{}section}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{fm}\PYG{o}{.}\PYG{n}{import\PYGZus{}areas\PYGZus{}section}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{fm}\PYG{o}{.}\PYG{n}{import\PYGZus{}yields\PYGZus{}section}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{fm}\PYG{o}{.}\PYG{n}{import\PYGZus{}actions\PYGZus{}section}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{fm}\PYG{o}{.}\PYG{n}{add\PYGZus{}null\PYGZus{}action}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{fm}\PYG{o}{.}\PYG{n}{import\PYGZus{}transitions\PYGZus{}section}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{fm}\PYG{o}{.}\PYG{n}{reset\PYGZus{}actions}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{fm}\PYG{o}{.}\PYG{n}{initialize\PYGZus{}areas}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{fm}\PYG{o}{.}\PYG{n}{grow}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{fm}
\end{sphinxVerbatim}

The next step in a typical workflow is to define one or more scenarios. Assuming that we are using an optimization approach to harvest scheduling, we need to define an objective function (e.g., maximize total harvest volume) and constraints (e.g., species-wise volume and area even-flow constraints, ending standing inventory constraints, periodic minimum late-seral-stage area constraints) %
\begin{footnote}[2]\sphinxAtStartFootnote
\sphinxcode{ws3} currently implements functions to formulate and solve \sphinxstyleemphasis{Model I} wood supply optimization problems—however, the package was deliberately designed to make it easy to transparently switch between \sphinxstyleemphasis{Model I},  \sphinxstyleemphasis{Model II} and \sphinxstyleemphasis{Model III} formulations without affecting the rest of the modelling workflow. \sphinxcode{ws3} currently has placeholder function stubs for \sphinxstyleemphasis{Model II} and \sphinxstyleemphasis{Model III} formulations, which will be implemented in later versions as the need arises. For more information on wood supply model formulations, see Chapter 16 of the \sphinxhref{http://www.springer.com/gp/book/9780387718149}{Handbook of Operations Research in Natural Resources}.
%
\end{footnote}, build the optimization model matrix, solve the model to optimality %
\begin{footnote}[3]\sphinxAtStartFootnote
\sphinxcode{ws3} currently uses the \sphinxhref{http://www.gurobi.com/}{Gurobi} solver to solve the linear programming (LP) problems to optimality. We chose Gurobi because it is one of the top two solvers currently available (along with the \sphinxhref{https://www.ibm.com/analytics/data-science/prescriptive-analytics/cplex-optimizer}{CPLEX} solver), has a simple and flexible policy for requesting unlimited licences for free use in research projects, has elegant Python bindings, and we like the technical documentation. However, we deliberately used a modular design, which allows us to transparently switch to a different solver in \sphinxcode{ws3} without affecting the rest of the workflow—this design will make it easy to implement an interface to addional solvers in future releases.
%
\end{footnote}.


\chapter{\sphinxstyleliteralintitle{ws3} Package Modules}
\label{\detokenize{modules::doc}}\label{\detokenize{modules:ws3-package-modules}}

\section{common module}
\label{\detokenize{common:common-module}}\label{\detokenize{common::doc}}\label{\detokenize{common:module-common}}\index{common (module)}
This module contains definitions for global attributes, functions, and classes that might be used anywhere in the package.
\begin{description}
\item[{Attributes:}] \leavevmode
HORIZON\_DEFAULT (int): Default value for ‘’.
PERIOD\_LENGTH\_DEFAULT (int): Default number of years per period.
MIN\_AGE\_DEFAULT (int): Default value for \sphinxtitleref{core.Curve.xmin}.
MAX\_AGE\_DEFAULT (int): Default value for \sphinxtitleref{core.Curve.xmax}.
CURVE\_EPSILON\_DEFAULT (float): Defalut value for \sphinxtitleref{core.Curve.epsilon}.

\end{description}

AREA\_EPSILON\_DEFAULT = 0.01
\index{Node (class in common)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.Node}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{common.}\sphinxbfcode{Node}}{\emph{nid}, \emph{data=None}, \emph{parent=None}}{}
Bases: \sphinxcode{object}
\index{add\_child() (common.Node method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.Node.add_child}}\pysiglinewithargsret{\sphinxbfcode{add\_child}}{\emph{child}}{}
\end{fulllineitems}

\index{children() (common.Node method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.Node.children}}\pysiglinewithargsret{\sphinxbfcode{children}}{}{}
\end{fulllineitems}

\index{data() (common.Node method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.Node.data}}\pysiglinewithargsret{\sphinxbfcode{data}}{\emph{key=None}}{}
\end{fulllineitems}

\index{is\_leaf() (common.Node method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.Node.is_leaf}}\pysiglinewithargsret{\sphinxbfcode{is\_leaf}}{}{}
\end{fulllineitems}

\index{is\_root() (common.Node method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.Node.is_root}}\pysiglinewithargsret{\sphinxbfcode{is\_root}}{}{}
\end{fulllineitems}

\index{parent() (common.Node method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.Node.parent}}\pysiglinewithargsret{\sphinxbfcode{parent}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{Tree (class in common)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.Tree}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{common.}\sphinxbfcode{Tree}}{\emph{period=1}}{}
Bases: \sphinxcode{object}
\index{add\_node() (common.Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.Tree.add_node}}\pysiglinewithargsret{\sphinxbfcode{add\_node}}{\emph{data}, \emph{parent=None}}{}
\end{fulllineitems}

\index{children() (common.Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.Tree.children}}\pysiglinewithargsret{\sphinxbfcode{children}}{\emph{nid}}{}
\end{fulllineitems}

\index{grow() (common.Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.Tree.grow}}\pysiglinewithargsret{\sphinxbfcode{grow}}{\emph{data}}{}
\end{fulllineitems}

\index{leaves() (common.Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.Tree.leaves}}\pysiglinewithargsret{\sphinxbfcode{leaves}}{}{}
\end{fulllineitems}

\index{node() (common.Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.Tree.node}}\pysiglinewithargsret{\sphinxbfcode{node}}{\emph{nid}}{}
\end{fulllineitems}

\index{nodes() (common.Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.Tree.nodes}}\pysiglinewithargsret{\sphinxbfcode{nodes}}{}{}
\end{fulllineitems}

\index{path() (common.Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.Tree.path}}\pysiglinewithargsret{\sphinxbfcode{path}}{\emph{leaf=None}}{}
\end{fulllineitems}

\index{paths() (common.Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.Tree.paths}}\pysiglinewithargsret{\sphinxbfcode{paths}}{}{}
\end{fulllineitems}

\index{root() (common.Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.Tree.root}}\pysiglinewithargsret{\sphinxbfcode{root}}{}{}
\end{fulllineitems}

\index{ungrow() (common.Tree method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.Tree.ungrow}}\pysiglinewithargsret{\sphinxbfcode{ungrow}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{clean\_vector\_data() (in module common)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.clean_vector_data}}\pysiglinewithargsret{\sphinxcode{common.}\sphinxbfcode{clean\_vector\_data}}{\emph{src\_path}, \emph{dst\_path}, \emph{dst\_name}, \emph{prop\_names}, \emph{clean=True}, \emph{tolerance=10.0}, \emph{preserve\_topology=True}, \emph{logfn='clean\_stand\_shapefile.log'}, \emph{max\_records=None}, \emph{theme0=None}, \emph{prop\_types=None}, \emph{driver='ESRI Shapefile'}, \emph{dst\_epsg=None}}{}
\end{fulllineitems}

\index{harv\_cost() (in module common)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.harv_cost}}\pysiglinewithargsret{\sphinxcode{common.}\sphinxbfcode{harv\_cost}}{\emph{piece\_size}, \emph{is\_finalcut}, \emph{is\_toleranthw}, \emph{partialcut\_extracare=False}, \emph{A=1.97}, \emph{B=0.405}, \emph{C=0.169}, \emph{D=0.164}, \emph{E=0.202}, \emph{F=13.6}, \emph{G=8.83}, \emph{K=0.0}, \emph{rv=False}}{}
Returns harvest cost, given piece size, treatment type (final cut or not), stand type (tolerant hardwood or not), partialcut “extra care” flag, and a series of regression coefficients (A, B, C, D, E, F, G, K, all with defaults {[}extracted from MERIS technical documentation; also see Sebastien Lacroix, BMMB{]}). 
Assumes that variables are deterministic.

\end{fulllineitems}

\index{harv\_cost\_rv() (in module common)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.harv_cost_rv}}\pysiglinewithargsret{\sphinxcode{common.}\sphinxbfcode{harv\_cost\_rv}}{\emph{tv\_mu}, \emph{tv\_sigma}, \emph{N\_mu}, \emph{N\_sigma}, \emph{psr}, \emph{is\_finalcut}, \emph{is\_toleranthw}, \emph{partialcut\_extracare=False}, \emph{tv\_min=50.0}, \emph{N\_min=200.0}, \emph{ps\_min=0.05}, \emph{E\_fromintegral=False}, \emph{e=0.01}, \emph{n=1000}}{}
Returns harvest cost, given piece size, treatment type (final cut or not), stand type (tolerant hardwood or not), partialcut “extra care” flag, and a series of regression coefficients (A, B, C, D, E, F, G, K, all with defaults {[}extracted from MERIS technical documentation; also see Sebastien Lacroix, BMMB{]}). 
Assumes that variables are random variates (returns expected value of function, using PaCAL packages to model random variates, assuming normal distribution for all three variables).
Can use either PaCAL numerical integration (sssslow!), or custom numerical integration using Monte Carlo sampling (default).

\end{fulllineitems}

\index{harv\_cost\_wec() (in module common)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.harv_cost_wec}}\pysiglinewithargsret{\sphinxcode{common.}\sphinxbfcode{harv\_cost\_wec}}{\emph{piece\_size}, \emph{is\_finalcut}, \emph{is\_toleranthw}, \emph{sigma}, \emph{nsigmas=3}, \emph{**kwargs}}{}
Estimate harvest cost with error correction.
:float piece\_size: mean piece size
:bool is\_finalcut: True if harvest treatment is final cut, False otherwise
:bool is\_toleranthw: True if tolerant hardwood cover type, False otherwise
:float sigma: standard deviation of piece size estimator
:int nsigmas: number of standard deviations to model on either side of the mean (default 3)
:float binw: width of bins for weighted numerical integration, in multiples of sigma (default 1.0)

\end{fulllineitems}

\index{hash\_dt() (in module common)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.hash_dt}}\pysiglinewithargsret{\sphinxcode{common.}\sphinxbfcode{hash\_dt}}{\emph{dt}, \emph{dtype='uint32'}, \emph{nbytes=4}}{}
\end{fulllineitems}

\index{is\_num() (in module common)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.is_num}}\pysiglinewithargsret{\sphinxcode{common.}\sphinxbfcode{is\_num}}{\emph{s}}{}
Returns True if s is a number.

\end{fulllineitems}

\index{piece\_size\_ratio() (in module common)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.piece_size_ratio}}\pysiglinewithargsret{\sphinxcode{common.}\sphinxbfcode{piece\_size\_ratio}}{\emph{treatment\_type}, \emph{cover\_type}, \emph{piece\_size\_ratios}}{}
Returns piece size ratio.
Assume Action.is\_harvest in {[}0, 1, 2, 3{]}
Assume cover\_type in {[}‘r’, ‘m’, ‘f’{]}
Return vr/vp ratio, where
\begin{quote}

vr is mean piece size of harvested stems, and
vp is mean piece size of stand before harvesting.
\end{quote}

\end{fulllineitems}

\index{rasterize\_stands() (in module common)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.rasterize_stands}}\pysiglinewithargsret{\sphinxcode{common.}\sphinxbfcode{rasterize\_stands}}{\emph{shp\_path}, \emph{tif\_path}, \emph{theme\_cols}, \emph{age\_col}, \emph{age\_divisor=1.0}, \emph{d=100.0}, \emph{dtype='uint32'}, \emph{compress='lzw'}, \emph{round\_coords=True}, \emph{value\_func=\textless{}function \textless{}lambda\textgreater{}\textgreater{}}, \emph{verbose=False}}{}
\end{fulllineitems}

\index{reproject() (in module common)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.reproject}}\pysiglinewithargsret{\sphinxcode{common.}\sphinxbfcode{reproject}}{\emph{f}, \emph{srs\_crs}, \emph{dst\_crs}}{}
\end{fulllineitems}

\index{reproject\_vector\_data() (in module common)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.reproject_vector_data}}\pysiglinewithargsret{\sphinxcode{common.}\sphinxbfcode{reproject\_vector\_data}}{\emph{src\_path}, \emph{snk\_path}, \emph{snk\_epsg}, \emph{driver='ESRI Shapefile'}}{}
\end{fulllineitems}

\index{sylv\_cred() (in module common)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.sylv_cred}}\pysiglinewithargsret{\sphinxcode{common.}\sphinxbfcode{sylv\_cred}}{\emph{P}, \emph{vr}, \emph{vp}, \emph{formula}}{}
Returns sylviculture credit (\$ per hectare), given P (volume harvested per hectare), vr (mean piece size of harvested stems), vp (mean piece size of stand before harvesting), and formula index (1 to 7).
Assumes that variables (P, vr, vp) are deterministic.

\end{fulllineitems}

\index{sylv\_cred\_formula() (in module common)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.sylv_cred_formula}}\pysiglinewithargsret{\sphinxcode{common.}\sphinxbfcode{sylv\_cred\_formula}}{\emph{treatment\_type}, \emph{cover\_type}}{}
Returns sylviculture credit formula index, given treatment type and cover type.

\end{fulllineitems}

\index{sylv\_cred\_rv() (in module common)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.sylv_cred_rv}}\pysiglinewithargsret{\sphinxcode{common.}\sphinxbfcode{sylv\_cred\_rv}}{\emph{P\_mu}, \emph{P\_sigma}, \emph{tv\_mu}, \emph{tv\_sigma}, \emph{N\_mu}, \emph{N\_sigma}, \emph{psr}, \emph{treatment\_type=None}, \emph{cover\_type=None}, \emph{formula=None}, \emph{P\_min=20.0}, \emph{tv\_min=50.0}, \emph{N\_min=200.0}, \emph{ps\_min=0.05}, \emph{E\_fromintegral=False}, \emph{e=0.01}, \emph{n=1000}}{}
Returns sylviculture credit (\$ per hectare), given P (volume harvested per hectare), vr (mean piece size of harvested stems), vp (mean piece size of stand before harvesting), and formula index (1 to 7).
Assumes that variables (P, vr, vp) are random variates (returns expected value of function, using PaCAL packages to model random variates, assuming normal distribution for all three variables).
Can use either PaCAL numerical integration (sssslow!), or custom numerical integration using Monte Carlo sampling (default).

\end{fulllineitems}

\index{timed() (in module common)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.timed}}\pysiglinewithargsret{\sphinxcode{common.}\sphinxbfcode{timed}}{\emph{func}}{}
\end{fulllineitems}

\index{warp\_raster() (in module common)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{common:common.warp_raster}}\pysiglinewithargsret{\sphinxcode{common.}\sphinxbfcode{warp\_raster}}{\emph{src}, \emph{dst\_path}, \emph{dst\_crs=\{'init': 'EPSG:4326'\}}}{}
\end{fulllineitems}



\section{core module}
\label{\detokenize{core:core-module}}\label{\detokenize{core::doc}}\label{\detokenize{core:module-core}}\index{core (module)}\index{Curve (class in core)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{core:core.Curve}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{core.}\sphinxbfcode{Curve}}{\emph{label=None}, \emph{id=None}, \emph{is\_volume=False}, \emph{points=None}, \emph{type='a'}, \emph{is\_special=False}, \emph{period\_length=10}, \emph{xmin=0}, \emph{xmax=1000}, \emph{epsilon=0.01}, \emph{simplify=True}}{}
Bases: \sphinxcode{object}

Describes change in state over time (between treatments)
\index{add\_points() (core.Curve method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{core:core.Curve.add_points}}\pysiglinewithargsret{\sphinxbfcode{add\_points}}{\emph{points}, \emph{simplify=True}, \emph{compile\_y=False}}{}
\end{fulllineitems}

\index{cai() (core.Curve method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{core:core.Curve.cai}}\pysiglinewithargsret{\sphinxbfcode{cai}}{}{}
\end{fulllineitems}

\index{lookup() (core.Curve method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{core:core.Curve.lookup}}\pysiglinewithargsret{\sphinxbfcode{lookup}}{\emph{y}, \emph{from\_right=False}, \emph{roundx=False}}{}
\end{fulllineitems}

\index{mai() (core.Curve method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{core:core.Curve.mai}}\pysiglinewithargsret{\sphinxbfcode{mai}}{}{}
\end{fulllineitems}

\index{points() (core.Curve method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{core:core.Curve.points}}\pysiglinewithargsret{\sphinxbfcode{points}}{}{}
\end{fulllineitems}

\index{range() (core.Curve method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{core:core.Curve.range}}\pysiglinewithargsret{\sphinxbfcode{range}}{\emph{lo=None}, \emph{hi=None}, \emph{as\_bounds=False}, \emph{left\_range=True}}{}
left\_range True:  ub lookup from left (default)
left\_range False: ub lookup from right (widest possible range)

\end{fulllineitems}

\index{simplify() (core.Curve method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{core:core.Curve.simplify}}\pysiglinewithargsret{\sphinxbfcode{simplify}}{\emph{points=None}, \emph{autotune=True}, \emph{compile\_y=False}, \emph{verbose=False}}{}
\end{fulllineitems}

\index{y() (core.Curve method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{core:core.Curve.y}}\pysiglinewithargsret{\sphinxbfcode{y}}{\emph{compile\_y=False}}{}
\end{fulllineitems}

\index{ytp() (core.Curve method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{core:core.Curve.ytp}}\pysiglinewithargsret{\sphinxbfcode{ytp}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{Interpolator (class in core)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{core:core.Interpolator}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{core.}\sphinxbfcode{Interpolator}}{\emph{points}}{}
Bases: \sphinxcode{object}

Interpolates x and y values from sparse curve point list.
\index{lookup() (core.Interpolator method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{core:core.Interpolator.lookup}}\pysiglinewithargsret{\sphinxbfcode{lookup}}{\emph{y}, \emph{from\_right=False}}{}
\end{fulllineitems}

\index{points() (core.Interpolator method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{core:core.Interpolator.points}}\pysiglinewithargsret{\sphinxbfcode{points}}{}{}
\end{fulllineitems}


\end{fulllineitems}



\section{forest module}
\label{\detokenize{forest:forest-module}}\label{\detokenize{forest::doc}}\label{\detokenize{forest:module-forest}}\index{forest (module)}
This module implements functions for building and running wood supply simulation
models.

The \sphinxcode{ForestModel} and \sphinxcode{DevelopmentType} classes constitute the core functional units of this module, and of the \sphinxcode{ws3} package in general.
\index{Action (class in forest)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.Action}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{forest.}\sphinxbfcode{Action}}{\emph{code}, \emph{targetage=None}, \emph{descr=''}, \emph{lockexempt=False}, \emph{components=None}, \emph{partial=None}, \emph{is\_harvest=0}}{}
Bases: \sphinxcode{object}

Encapsulates data for an action.

\end{fulllineitems}

\index{DevelopmentType (class in forest)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.DevelopmentType}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{forest.}\sphinxbfcode{DevelopmentType}}{\emph{key}, \emph{parent}}{}
Bases: \sphinxcode{object}

Encapsulates Forest development type data (curves, age, area), and provides methods to operate on the data.

The key is basically the fully expanded mask (expressed as a tuple of values). The parent is a reference to the ForestModel object in which self is embedded.
\index{add\_ycomp() (forest.DevelopmentType method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.DevelopmentType.add_ycomp}}\pysiglinewithargsret{\sphinxbfcode{add\_ycomp}}{\emph{ytype}, \emph{yname}, \emph{ycomp}, \emph{first\_match=True}}{}
\end{fulllineitems}

\index{area() (forest.DevelopmentType method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.DevelopmentType.area}}\pysiglinewithargsret{\sphinxbfcode{area}}{\emph{period}, \emph{age=None}, \emph{area=None}, \emph{delta=True}}{}
If area not specified, returns area inventory for period (optionally age), else sets area for period and age. 
If delta switch active (default True), area value is interpreted as an increment on current inventory.

\end{fulllineitems}

\index{compile\_action() (forest.DevelopmentType method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.DevelopmentType.compile_action}}\pysiglinewithargsret{\sphinxbfcode{compile\_action}}{\emph{acode}, \emph{verbose=False}}{}
Compile action, given action code. 
This mostly involves resolving operability expression strings into
lower and upper operability limits, defined as (alo, ahi) age pair for each period.
Deletes action from self if not operable in any period.

\end{fulllineitems}

\index{compile\_actions() (forest.DevelopmentType method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.DevelopmentType.compile_actions}}\pysiglinewithargsret{\sphinxbfcode{compile\_actions}}{\emph{verbose=False}}{}
Compile all actions.

\end{fulllineitems}

\index{grow() (forest.DevelopmentType method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.DevelopmentType.grow}}\pysiglinewithargsret{\sphinxbfcode{grow}}{\emph{start\_period=1}, \emph{cascade=True}}{}
Grow self (default starting period 1, and cascading to end of planning horizon).

\end{fulllineitems}

\index{initialize\_areas() (forest.DevelopmentType method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.DevelopmentType.initialize_areas}}\pysiglinewithargsret{\sphinxbfcode{initialize\_areas}}{}{}
Copy initial inventory to period-1 inventory.

\end{fulllineitems}

\index{is\_operable() (forest.DevelopmentType method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.DevelopmentType.is_operable}}\pysiglinewithargsret{\sphinxbfcode{is\_operable}}{\emph{acode}, \emph{period}, \emph{age=None}, \emph{verbose=False}}{}
Test hypothetical operability.
Does not imply that there is any operable area in current inventory.

\end{fulllineitems}

\index{operable\_ages() (forest.DevelopmentType method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.DevelopmentType.operable_ages}}\pysiglinewithargsret{\sphinxbfcode{operable\_ages}}{\emph{acode}, \emph{period}}{}
Finds list of ages at which self is operable, given an action code and period index.

\end{fulllineitems}

\index{operable\_area() (forest.DevelopmentType method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.DevelopmentType.operable_area}}\pysiglinewithargsret{\sphinxbfcode{operable\_area}}{\emph{acode}, \emph{period}, \emph{age=None}, \emph{cleanup=True}}{}
Returns 0 if inoperable or no current inventory, operable area given action code and period 
(and optionally age) index otherwise. If cleanup switch activated (default True) and age specified, 
deletes the ageclass from the inventory dict if operable area is less than self.parent.area\_epsilon.

\end{fulllineitems}

\index{reset\_areas() (forest.DevelopmentType method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.DevelopmentType.reset_areas}}\pysiglinewithargsret{\sphinxbfcode{reset\_areas}}{\emph{period=None}}{}
Reset areas dict.

\end{fulllineitems}

\index{resolve\_condition() (forest.DevelopmentType method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.DevelopmentType.resolve_condition}}\pysiglinewithargsret{\sphinxbfcode{resolve\_condition}}{\emph{yname}, \emph{lo}, \emph{hi}}{}
Find lower and upper ages that correspond to lo and hi values of yname (interpreted as first occurence of yield value, reading curve from left and right, respectively).

\end{fulllineitems}

\index{ycomp() (forest.DevelopmentType method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.DevelopmentType.ycomp}}\pysiglinewithargsret{\sphinxbfcode{ycomp}}{\emph{yname}, \emph{silent\_fail=True}}{}
\end{fulllineitems}

\index{ycomps() (forest.DevelopmentType method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.DevelopmentType.ycomps}}\pysiglinewithargsret{\sphinxbfcode{ycomps}}{}{}
Returns list of yield component keys.

\end{fulllineitems}


\end{fulllineitems}

\index{ForestModel (class in forest)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{forest.}\sphinxbfcode{ForestModel}}{\emph{model\_name}, \emph{model\_path}, \emph{horizon=30}, \emph{period\_length=10}, \emph{max\_age=1000}, \emph{area\_epsilon=0.01}, \emph{curve\_epsilon=0.01}}{}
Bases: \sphinxcode{object}

This is the core class of the ws3 package.
Includes methods import data from various sources, simulate growth and apply actions.
The model can be used in either a (prescriptive) simulation-based approach or a (descriptive) optimization-based approach.

This class encapsulates all the information used to simulate scenarios from a given dataset (i.e., stratified intial inventory, growth and yield functions, action eligibility, transition matrix, action schedule, etc.), as well as a large collection of functions to import and export data, generate activity schedules, and simulate application of these schedules  (i.e., run scenarios).

At the heart of the \sphinxcode{ForestModel} class is a list of \sphinxcode{DevelopentType} instances. Each \sphinxcode{DevelopmentType} instance encapsulates information about one development type (i.e., a forest stratum, which is an aggregate of smaller \sphinxstyleemphasis{stands} that make up the raw forest inventory input data). The \sphinxcode{DevelopmentType} class also stores a list of operable \sphinxstyleemphasis{actions}, maps \sphinxstyleemphasis{state variable transitions} to these actions, stores growth and yield functions, and knows how to \sphinxstyleemphasis{grow itself} when time is incremented during a simulation.

A typical use case starts with creating an instance of the \sphinxcode{ForestModel} class. Then, we need to load data into this instance, define one or more scenarios (using a mix of heuristic and optimization approaches), run the scenarios, and export output data to a format suitable for analysis (or link to the next model in a larger modelling pipeline).
\index{add\_null\_action() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.add_null_action}}\pysiglinewithargsret{\sphinxbfcode{add\_null\_action}}{\emph{acode='null'}, \emph{minage=None}, \emph{maxage=None}}{}
\end{fulllineitems}

\index{add\_problem() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.add_problem}}\pysiglinewithargsret{\sphinxbfcode{add\_problem}}{\emph{name}, \emph{coeff\_funcs}, \emph{cflw\_e}, \emph{cgen\_data=None}, \emph{solver='gurobi'}, \emph{formulation=1}, \emph{z\_coeff\_key='z'}, \emph{acodes=None}}{}
\end{fulllineitems}

\index{add\_theme() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.add_theme}}\pysiglinewithargsret{\sphinxbfcode{add\_theme}}{\emph{name}, \emph{basecodes={[}{]}}, \emph{aggs=\{\}}}{}
\end{fulllineitems}

\index{age\_class\_distribution() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.age_class_distribution}}\pysiglinewithargsret{\sphinxbfcode{age\_class\_distribution}}{\emph{period}, \emph{mask=None}}{}
Returns age class distribution (dict of areas, keys on age).

\end{fulllineitems}

\index{apply\_action() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.apply_action}}\pysiglinewithargsret{\sphinxbfcode{apply\_action}}{\emph{dtype\_key}, \emph{acode}, \emph{period}, \emph{age}, \emph{area}, \emph{override\_operability=False}, \emph{fuzzy\_age=True}, \emph{recourse\_enabled=True}, \emph{areaselector=None}, \emph{compile\_t\_ycomps=False}, \emph{compile\_c\_ycomps=False}, \emph{verbose=False}}{}
Applies action, given action code, development type, period, age, area.
Can optionally override operability limits, optionally use fuzzy age (i.e., attempt to apply action 
to proximal age class if specified age is not operable), optionally use default AreaSelector to patch
missing area (if recourse enabled). Applying an action is a rather complex process, involving testing 
for operability (JIT-compiling operability expression as required), checking that valid transitions 
are defined, checking that area is available (possibly using fuzzy age and area selector functions to
find missing area), generate list of target development types (from source development type and 
transition expressions {[}which may need to be JIT-compiled{]}), creating new development types (as needed), 
doing the area accounting correctly (without creating or destroying any area), and compiling the products
from the action (which gets a bit complicated in the case of partial cuts…).

Returns (errorcode, missing\_area, target\_dt) triplet, where errorcode is an error code, missing\_area is 
the missing area, and target\_dt is a list of (dtk, tprop, targetage) triplets (one triplet per target 
development type).

\end{fulllineitems}

\index{apply\_schedule() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.apply_schedule}}\pysiglinewithargsret{\sphinxbfcode{apply\_schedule}}{\emph{schedule}, \emph{max\_period=None}, \emph{verbose=False}, \emph{fail\_on\_missingarea=False}, \emph{force\_integral\_area=False}, \emph{override\_operability=False}, \emph{fuzzy\_age=True}, \emph{recourse\_enabled=True}, \emph{areaselector=None}, \emph{compile\_t\_ycomps=False}, \emph{compile\_c\_ycomps=False}}{}
Assumes schedule in format returned by import\_schedule\_section().
That is: list of (dtype\_key, age, area, acode, period, etype) tuples.
Also assumes that actions in list are sorted by applied period.

\end{fulllineitems}

\index{commit\_actions() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.commit_actions}}\pysiglinewithargsret{\sphinxbfcode{commit\_actions}}{\emph{period=1}, \emph{repair\_future\_actions=False}, \emph{verbose=False}}{}
Commits applied actions (i.e., apply transitions and grow, default starting at period 1).
By default, will attempt to repair broken (infeasible) future actions, attempting to replace infeasiblea operated area using default AreaSelector.

\end{fulllineitems}

\index{compile\_product() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.compile_product}}\pysiglinewithargsret{\sphinxbfcode{compile\_product}}{\emph{period}, \emph{expr}, \emph{acode=None}, \emph{dtype\_keys=None}, \emph{age=None}, \emph{coeff=False}, \emph{verbose=False}}{}
Compiles products from applied actions in given period. Parses string expression, which resolves to a single coefficient. 
Operated area can be filtered on action code, development type key list, and age. Result is product of sum of filtered 
area and coefficient.

\end{fulllineitems}

\index{compile\_schedule() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.compile_schedule}}\pysiglinewithargsret{\sphinxbfcode{compile\_schedule}}{\emph{problem}, \emph{formulation=1}, \emph{skip\_null='null'}}{}
Compiles a \sphinxcode{ws3}-compatible schedule data object from a solved \sphinxcode{ws3.opt.Problem} instance. This is just a dispatcher function—the actual compilation is done by a formulation-specific function (assumes \sphinxstyleemphasis{Model I} formulation if not specified).

\end{fulllineitems}

\index{create\_dtype\_fromkey() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.create_dtype_fromkey}}\pysiglinewithargsret{\sphinxbfcode{create\_dtype\_fromkey}}{\emph{key}}{}
Creates a new development type, given a key (checks for existing, auto-assigns yield compompontents, 
auto-assign actions and transitions, checks for operability (filed under inoperable if applicable).

\end{fulllineitems}

\index{dt() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.dt}}\pysiglinewithargsret{\sphinxbfcode{dt}}{\emph{dtype\_key}}{}
Returns development type, given key (returns None on invalid key).

\end{fulllineitems}

\index{grow() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.grow}}\pysiglinewithargsret{\sphinxbfcode{grow}}{\emph{start\_period=1}, \emph{cascade=True}}{}
Simulates growth (default startint at period 1 and cascading to the end of the planning horizon).

\end{fulllineitems}

\index{import\_actions\_section() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.import_actions_section}}\pysiglinewithargsret{\sphinxbfcode{import\_actions\_section}}{\emph{filename\_suffix='act'}, \emph{mask\_func=None}, \emph{nthemes=None}}{}
Imports ACTIONS section from a Forest model.

\end{fulllineitems}

\index{import\_areas\_section() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.import_areas_section}}\pysiglinewithargsret{\sphinxbfcode{import\_areas\_section}}{\emph{model\_path=None}, \emph{model\_name=None}, \emph{filename\_suffix='are'}, \emph{import\_empty=False}}{}
Imports AREAS section from a Forest model.

\end{fulllineitems}

\index{import\_constants\_section() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.import_constants_section}}\pysiglinewithargsret{\sphinxbfcode{import\_constants\_section}}{\emph{filename\_suffix='con'}}{}
Imports CONSTANTS section from a Forest model.

\end{fulllineitems}

\index{import\_control\_section() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.import_control_section}}\pysiglinewithargsret{\sphinxbfcode{import\_control\_section}}{\emph{filename\_suffix='run'}}{}
Imports CONTROL section from a Forest model.
.. warning:: Not implemented yet.

\end{fulllineitems}

\index{import\_graphics\_section() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.import_graphics_section}}\pysiglinewithargsret{\sphinxbfcode{import\_graphics\_section}}{\emph{filename\_suffix='gra'}}{}
Imports GRAPHICS section from a Forest model.
.. warning:: Not implemented yet.

\end{fulllineitems}

\index{import\_landscape\_section() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.import_landscape_section}}\pysiglinewithargsret{\sphinxbfcode{import\_landscape\_section}}{\emph{filename\_suffix='lan'}, \emph{ti\_offset=0}}{}
Imports LANDSCAPE section from a Forest model.

\end{fulllineitems}

\index{import\_lifespan\_section() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.import_lifespan_section}}\pysiglinewithargsret{\sphinxbfcode{import\_lifespan\_section}}{\emph{filename\_suffix='lif'}}{}
Imports LIFESPAN section from a Forest model.
.. warning:: Not implemented yet.

\end{fulllineitems}

\index{import\_optimize\_section() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.import_optimize_section}}\pysiglinewithargsret{\sphinxbfcode{import\_optimize\_section}}{\emph{filename\_suffix='opt'}}{}
Imports OPTIMIZE section from a Forest model.
.. warning:: Not implemented yet.

\end{fulllineitems}

\index{import\_outputs\_section() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.import_outputs_section}}\pysiglinewithargsret{\sphinxbfcode{import\_outputs\_section}}{\emph{filename\_suffix='out'}}{}
Imports OUTPUTS section from a Forest model.

\end{fulllineitems}

\index{import\_schedule\_section() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.import_schedule_section}}\pysiglinewithargsret{\sphinxbfcode{import\_schedule\_section}}{\emph{filename\_suffix='seq'}, \emph{replace\_commas=True}, \emph{filename\_prefix=None}}{}
Imports SCHEDULE section from a Forest model.

\end{fulllineitems}

\index{import\_transitions\_section() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.import_transitions_section}}\pysiglinewithargsret{\sphinxbfcode{import\_transitions\_section}}{\emph{filename\_suffix='trn'}, \emph{mask\_func=None}, \emph{nthemes=None}}{}
Imports TRANSITIONS section from a Forest model.

\end{fulllineitems}

\index{import\_yields\_section() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.import_yields_section}}\pysiglinewithargsret{\sphinxbfcode{import\_yields\_section}}{\emph{filename\_suffix='yld'}, \emph{mask\_func=None}, \emph{verbose=False}}{}
Imports YIELDS section from a Forest model.

\end{fulllineitems}

\index{initialize\_areas() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.initialize_areas}}\pysiglinewithargsret{\sphinxbfcode{initialize\_areas}}{}{}
Copies areas from period 0 to period 1.

\end{fulllineitems}

\index{inventory() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.inventory}}\pysiglinewithargsret{\sphinxbfcode{inventory}}{\emph{period}, \emph{yname=None}, \emph{age=None}, \emph{mask=None}, \emph{dtype\_keys=None}}{}
Flexible method that compiles inventory at given period.
Unit of return data defaults to area if yname not given, 
but takes on unit of yield component otherwise. 
Can be constrained by age and development type mask.

\end{fulllineitems}

\index{is\_harvest() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.is_harvest}}\pysiglinewithargsret{\sphinxbfcode{is\_harvest}}{\emph{acode}}{}
Returns True if acode corresponds to a harvesting action.

\end{fulllineitems}

\index{match\_mask() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.match_mask}}\pysiglinewithargsret{\sphinxbfcode{match\_mask}}{\emph{mask}, \emph{key}}{}
Returns True if key matches mask.

\end{fulllineitems}

\index{operable\_area() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.operable_area}}\pysiglinewithargsret{\sphinxbfcode{operable\_area}}{\emph{acode}, \emph{period}, \emph{age=None}}{}
Returns total operable area, given action code and period (and optionally age).

\end{fulllineitems}

\index{operable\_dtypes() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.operable_dtypes}}\pysiglinewithargsret{\sphinxbfcode{operable\_dtypes}}{\emph{acode}, \emph{period}, \emph{mask=None}}{}
Returns dict (keyed on development type key, values are lists of operable ages).

\end{fulllineitems}

\index{operated\_area() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.operated_area}}\pysiglinewithargsret{\sphinxbfcode{operated\_area}}{\emph{acode}, \emph{period}, \emph{dtype\_key=None}, \emph{age=None}}{}
Compiles operated area, given action code and period (and optionally list of development type keys or age).

\end{fulllineitems}

\index{piece\_size() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.piece_size}}\pysiglinewithargsret{\sphinxbfcode{piece\_size}}{\emph{dtype\_key}, \emph{age}}{}
Returns piece size, given development type key and age.

\end{fulllineitems}

\index{register\_curve() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.register_curve}}\pysiglinewithargsret{\sphinxbfcode{register\_curve}}{\emph{curve}}{}
Add curve to global curve hash map (uses result of Curve.points() to construct hash key).

\end{fulllineitems}

\index{repair\_actions() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.repair_actions}}\pysiglinewithargsret{\sphinxbfcode{repair\_actions}}{\emph{period}, \emph{areaselector=None}}{}
Attempts to repair the action schedule for given period, using an AreaSelector object (defaults to class-default areaselector, which is a simple greedy oldest-first selector).

\end{fulllineitems}

\index{reset\_actions() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.reset_actions}}\pysiglinewithargsret{\sphinxbfcode{reset\_actions}}{\emph{period=None}, \emph{acode=None}}{}
Resets actions (default resets all periods, all actions, unless period or acode specified).

\end{fulllineitems}

\index{resolve\_append() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.resolve_append}}\pysiglinewithargsret{\sphinxbfcode{resolve\_append}}{\emph{dtk}, \emph{expr}}{}
\end{fulllineitems}

\index{resolve\_condition() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.resolve_condition}}\pysiglinewithargsret{\sphinxbfcode{resolve\_condition}}{\emph{condition}, \emph{dtype\_key=None}}{}
Evaluate @AGE or @YLD condition.
Returns list of ages.

\end{fulllineitems}

\index{resolve\_replace() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.resolve_replace}}\pysiglinewithargsret{\sphinxbfcode{resolve\_replace}}{\emph{dtk}, \emph{expr}}{}
\end{fulllineitems}

\index{resolve\_tappend() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.resolve_tappend}}\pysiglinewithargsret{\sphinxbfcode{resolve\_tappend}}{\emph{dt}, \emph{tappend}}{}
\end{fulllineitems}

\index{resolve\_targetage() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.resolve_targetage}}\pysiglinewithargsret{\sphinxbfcode{resolve\_targetage}}{\emph{dtk}, \emph{tyield}, \emph{sage}, \emph{tage}, \emph{acode}, \emph{verbose=False}}{}
\end{fulllineitems}

\index{resolve\_tmask() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.resolve_tmask}}\pysiglinewithargsret{\sphinxbfcode{resolve\_tmask}}{\emph{dt}, \emph{tmask}, \emph{treplace}, \emph{tappend}}{}
Returns new developement type key (tuple of values, one per theme), given developement type and (treplace, tappend) expressions.

\end{fulllineitems}

\index{resolve\_treplace() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.resolve_treplace}}\pysiglinewithargsret{\sphinxbfcode{resolve\_treplace}}{\emph{dt}, \emph{treplace}}{}
\end{fulllineitems}

\index{sylv\_cred\_formula() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.sylv_cred_formula}}\pysiglinewithargsret{\sphinxbfcode{sylv\_cred\_formula}}{\emph{treatment\_type}, \emph{cover\_type}}{}
\end{fulllineitems}

\index{theme\_basecodes() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.theme_basecodes}}\pysiglinewithargsret{\sphinxbfcode{theme\_basecodes}}{\emph{theme\_index}}{}
Return list of base codes, given theme index.

\end{fulllineitems}

\index{tree() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.tree}}\pysiglinewithargsret{\sphinxbfcode{tree}}{}{}
\end{fulllineitems}

\index{unmask() (forest.ForestModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.ForestModel.unmask}}\pysiglinewithargsret{\sphinxbfcode{unmask}}{\emph{mask}}{}
Iteratively filter list of development type keys using mask values.
Accepts Forest-style string masks to facilitate cut-and-paste testing.

\end{fulllineitems}


\end{fulllineitems}

\index{GreedyAreaSelector (class in forest)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.GreedyAreaSelector}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{forest.}\sphinxbfcode{GreedyAreaSelector}}{\emph{parent}}{}
Bases: \sphinxcode{object}

Default AreaSelector implementation. Selects areas for treatment from oldest age classes.
\index{operate() (forest.GreedyAreaSelector method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.GreedyAreaSelector.operate}}\pysiglinewithargsret{\sphinxbfcode{operate}}{\emph{period}, \emph{acode}, \emph{target\_area}, \emph{mask=None}, \emph{commit\_actions=True}, \emph{verbose=False}}{}
Greedily operate on oldest operable age classes.
Returns missing area (i.e., difference between target and operated areas).

\end{fulllineitems}


\end{fulllineitems}

\index{Output (class in forest)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{forest:forest.Output}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{forest.}\sphinxbfcode{Output}}{\emph{parent}, \emph{code=None}, \emph{expression=None}, \emph{factor=(1.0}, \emph{1)}, \emph{description=''}, \emph{theme\_index=-1}, \emph{is\_basic=False}, \emph{is\_level=False}}{}
Bases: \sphinxcode{object}

Encapsulates data and methods to operate on aggregate outputs from the model.
Emulates behaviour of Forest outputs.
.. warning:: Behaviour of Forest outputs is quite complex. 
This class needs more work before it is used in a production setting 
(i.e., resolution of some complex output cases is buggy).

\end{fulllineitems}



\section{opt module}
\label{\detokenize{opt::doc}}\label{\detokenize{opt:module-opt}}\label{\detokenize{opt:opt-module}}\index{opt (module)}
This module implements functions for formulating and solving optimization problems.
The notation is very generic (i.e., refers to variables, constraints, problems, solutions, etc.).
All the wood-supply-problem\textendash{}specific references are implemented in the \sphinxcode{forest} module.

The \sphinxcode{Problem} class is the main functional unit here. It encapsulates optimization problem data (i.e., variables, constraints, objective function, and optimal solution), as well as methods to operate on this data (i.e., methods to build and solve the problem, and report on the optimal solution).

Note that we implemented a modular design that decouples the implementation from the choice of solver. Currently, only bindings to the Gurobi solver are implemented, although bindings to other solvers can easilty be added (we will add more binding in later releases, as the need arises).
\index{Constraint (class in opt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{opt:opt.Constraint}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{opt.}\sphinxbfcode{Constraint}}{\emph{name}, \emph{coeffs}, \emph{sense}, \emph{rhs}}{}
Bases: \sphinxcode{object}

Encapsulates data describing a constraint in an optimization problem. This includes a constraint name (should be unique within a problem, although the user is responsible for enforcing this condition), a vector of coefficient values (length of vector should match the number of variables in the problem, although the user is responsible for enforcing this condition), a sense (should be one of \sphinxcode{SENSE\_EQ}, \sphinxcode{SENSE\_GEQ}, or \sphinxcode{SENSE\_LEQ}), and a right-hand-side value.

\end{fulllineitems}

\index{Problem (class in opt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{opt:opt.Problem}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{opt.}\sphinxbfcode{Problem}}{\emph{name}, \emph{sense=-1}, \emph{solver='gurobi'}}{}
Bases: \sphinxcode{object}

This is the main class of the \sphinxcode{opt} module—it encapsulates optimization problem data (i.e., variables, constraints, objective function, optimal solution, and choice of solver), as well as methods to operate on this data (i.e., methods to build and solve the problem, and report on the optimal solution).
\index{add\_constraint() (opt.Problem method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{opt:opt.Problem.add_constraint}}\pysiglinewithargsret{\sphinxbfcode{add\_constraint}}{\emph{name}, \emph{coeffs}, \emph{sense}, \emph{rhs}, \emph{validate=False}}{}
Adds a constraint to the problem. The constraint name should be unique within the problem (user is responsible for enforcing this condition). Constraint coeffients should be provided as a \sphinxcode{dict}, keyed on variable names—length of constraint coefficient \sphinxcode{dict} should match number of variables in the problem (user is responsible for enforcing this condition). Constraint sense should be one of \sphinxcode{SENSE\_EQ}, \sphinxcode{SENSE\_GEQ}, or \sphinxcode{SENSE\_LEQ}.

Note that calling this method resets the value of the optimal solution to \sphinxcode{None}.

\end{fulllineitems}

\index{add\_var() (opt.Problem method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{opt:opt.Problem.add_var}}\pysiglinewithargsret{\sphinxbfcode{add\_var}}{\emph{name}, \emph{vtype}, \emph{lb=0.0}, \emph{ub=inf}}{}
Adds a variable to the problem. The variable name should be unique within the problem (user is responsible for enforcing this condition). Variable type should be one of \sphinxcode{VTYPE\_CONTINUOUS}, \sphinxcode{VTYPE\_INTEGER}, or \sphinxcode{VTYPE\_BINARY}. Variable value bounds default to zero for the lower bound and positive infinity for the upper bound.

Note that calling this method resets the value of the optimal solution to \sphinxcode{None}.

\end{fulllineitems}

\index{constraint\_names() (opt.Problem method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{opt:opt.Problem.constraint_names}}\pysiglinewithargsret{\sphinxbfcode{constraint\_names}}{}{}
Returns a list of constraint names.

\end{fulllineitems}

\index{name() (opt.Problem method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{opt:opt.Problem.name}}\pysiglinewithargsret{\sphinxbfcode{name}}{}{}
Returns problem name.

\end{fulllineitems}

\index{sense() (opt.Problem method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{opt:opt.Problem.sense}}\pysiglinewithargsret{\sphinxbfcode{sense}}{\emph{val=None}}{}
Returns (or sets) objective function sense. Value should be one of \sphinxcode{SENSE\_MINIMIZE} or \sphinxcode{SENSE\_MAXIMIZE}.

\end{fulllineitems}

\index{solution() (opt.Problem method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{opt:opt.Problem.solution}}\pysiglinewithargsret{\sphinxbfcode{solution}}{}{}
Returns a \sphinxcode{dict} of variable values, keyed on variable names.

\end{fulllineitems}

\index{solve() (opt.Problem method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{opt:opt.Problem.solve}}\pysiglinewithargsret{\sphinxbfcode{solve}}{\emph{validate=False}}{}
Solves the optimization problem. Dispatches to a solver-specific method (only Gurobi bindings are implemented at this time).

\end{fulllineitems}

\index{solved() (opt.Problem method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{opt:opt.Problem.solved}}\pysiglinewithargsret{\sphinxbfcode{solved}}{}{}
Returns \sphinxcode{True} if the problem has been solved, \sphinxcode{False} otherwise.

\end{fulllineitems}

\index{solver() (opt.Problem method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{opt:opt.Problem.solver}}\pysiglinewithargsret{\sphinxbfcode{solver}}{\emph{val}}{}
Sets the solver (defaults to \sphinxcode{{}`SOLVER\_GUROBI{}`} in the class constructor). Note that only Gurobi solver bindings are implemented at this time.

\end{fulllineitems}

\index{var() (opt.Problem method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{opt:opt.Problem.var}}\pysiglinewithargsret{\sphinxbfcode{var}}{\emph{name}}{}
Returns a \sphinxcode{Variable} instance, given a variable name.

\end{fulllineitems}

\index{var\_names() (opt.Problem method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{opt:opt.Problem.var_names}}\pysiglinewithargsret{\sphinxbfcode{var\_names}}{}{}
Return a list of variable names.

\end{fulllineitems}

\index{z() (opt.Problem method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{opt:opt.Problem.z}}\pysiglinewithargsret{\sphinxbfcode{z}}{\emph{coeffs=None}, \emph{validate=False}}{}
Returns the objective function value if \sphinxcode{coeffs} is not provided (triggers an exception if problem has not been solved yet), or updates the objective function coefficient vector (resets the value of the optimal solution to \sphinxcode{None}).

\end{fulllineitems}


\end{fulllineitems}

\index{Variable (class in opt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{opt:opt.Variable}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{opt.}\sphinxbfcode{Variable}}{\emph{name}, \emph{vtype}, \emph{lb=0.0}, \emph{ub=inf}, \emph{val=None}}{}
Bases: \sphinxcode{object}

Encapsulates data describing a variable in an optimization problem. This includes a variable name (should be unique within a problem, although the user is responsible for enforcing this condition), a variable type (should be one of \sphinxcode{VTYPE\_CONTINUOUS}, \sphinxcode{VTYPE\_INTEGER}, or \sphinxcode{VTYPE\_BINARY}), variable value bound (lower bound defaults to zero, upper bound defaults to positive infinity), and variable value (defaults to \sphinxcode{None}).

\end{fulllineitems}



\section{\sphinxstyleliteralintitle{spatial} module}
\label{\detokenize{spatial::doc}}\label{\detokenize{spatial:spatial-module}}\phantomsection\label{\detokenize{spatial:module-spatial}}\index{spatial (module)}\index{ForestRaster (class in spatial)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spatial:spatial.ForestRaster}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{spatial.}\sphinxbfcode{ForestRaster}}{\emph{hdt\_map}, \emph{hdt\_func}, \emph{src\_path}, \emph{snk\_path}, \emph{acodes}, \emph{horizon}, \emph{base\_year}, \emph{period\_length=1}, \emph{tif\_compress='lzw'}, \emph{tif\_dtype='uint8'}, \emph{piggyback\_acodes=None}}{}
Bases: \sphinxcode{object}

The \sphinxcode{ForestRaster} class can be used to allocate an aspatial disturbance schedule (for example, an optimal solution to a wood supply problem generated by an instance of the \sphinxcode{forest.ForestModel} class) to a rasterized representation of the forest inventory.
\begin{quote}
\begin{quote}\begin{description}
\item[{param hdt\_map}] \leavevmode
A dictionary mapping hash values to development types. The rasterized forest inventory is stored in a 2-layer GeoTIFF file. Pixel values for the first layer represent the \sphinxstyleemphasis{theme} values (i.e., the stratification variables used to stratify the forest inventory into development types). The value of the \sphinxcode{hdt\_map} parameter is used to \sphinxstyleemphasis{expand} hash value back into a tuple of theme values.

\item[{type hdt\_map}] \leavevmode
dict

\item[{param hdt\_func}] \leavevmode
A function that accepts a tuple of theme values, and returns a hash value. Must be the same function used to encode the rasterized forest inventory (see documentation of the \sphinxcode{hdt\_map} parameter, above).

\item[{param src\_path}] \leavevmode
Filesystem path pointing to the input GeoTIFF file (i.e., the rasterized forest inventory). Note that this file will be used as a model for the output GeoTIFF files (i.e., pixel matrix height and width, coordinate reference system, compression parameters, etc.).

\item[{param snk\_path}] \leavevmode
Filesystem path pointing to a directory where the output GeoTIFF files. The output GeoTIFF files are automatically created inside the class constructor method (one GeoTIFF file for each combination of disturbance type and year. If the disturbance schedule is from a \sphinxcode{ForestModel} instance that uses multi-year periods, then the \sphinxcode{ForestRaster} class automatically disaggregates the periodic solution into annual time steps.

\item[{param acodes}] \leavevmode
List of disturbance codes.

\item[{param horizon}] \leavevmode
Length of planning horizon (expressed as a number of periods).

\item[{param base\_year}] \leavevmode
Base year for numbering of annual time steps.

\item[{param period\_length}] \leavevmode
Length of planning period in the \sphinxcode{ForestModel} instance used to generate the disturbance schedule.

\item[{param tiff\_compress}] \leavevmode
GeoTIFF compression mode (uses LZW lossless compression by default).

\item[{param tif\_dtype}] \leavevmode
Data type for output GeoTIFF files (defaults to \sphinxcode{rasterio.uint8}, i.e., an 8-byte unsigned integer).

\item[{param piggyback\_acodes}] \leavevmode
A dictionary of list of tuples, describing piggyback disturbance parameters. By \sphinxstyleemphasis{piggyback} disturbance, we mean a disturbance that was not explicitly scheduled by the \sphinxcode{ForestModel} instance, but rather is modelled as a (randomly-selected) subset of one of the explicitly modelled disturbances.

\end{description}\end{quote}
\end{quote}

For example, if we want to model that 85\% of pixels disturbed using the \sphinxstyleemphasis{clearcut} disturbance are disturbed by a piggybacked \sphinxstyleemphasis{slashburn} disturbance, we would pass
\begin{quote}

\sphinxcode{piggyback\_acodes=\{'clearcut':{[}('slashburn', 0.85){]}\}}.
\end{quote}
\index{allocate\_schedule() (spatial.ForestRaster method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spatial:spatial.ForestRaster.allocate_schedule}}\pysiglinewithargsret{\sphinxbfcode{allocate\_schedule}}{\emph{forestmodel}, \emph{da=0}, \emph{fudge=1.0}, \emph{mask=None}, \emph{verbose=False}}{}
\end{fulllineitems}

\index{cleanup() (spatial.ForestRaster method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spatial:spatial.ForestRaster.cleanup}}\pysiglinewithargsret{\sphinxbfcode{cleanup}}{}{}
\end{fulllineitems}

\index{commit() (spatial.ForestRaster method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spatial:spatial.ForestRaster.commit}}\pysiglinewithargsret{\sphinxbfcode{commit}}{}{}
\end{fulllineitems}

\index{grow() (spatial.ForestRaster method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spatial:spatial.ForestRaster.grow}}\pysiglinewithargsret{\sphinxbfcode{grow}}{}{}
\end{fulllineitems}

\index{transition\_cells\_random() (spatial.ForestRaster method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spatial:spatial.ForestRaster.transition_cells_random}}\pysiglinewithargsret{\sphinxbfcode{transition\_cells\_random}}{\emph{from\_dtk}, \emph{from\_age}, \emph{to\_dtk}, \emph{to\_age}, \emph{tarea}, \emph{acode}, \emph{dy}, \emph{da=0}, \emph{fudge=1.0}, \emph{verbose=False}}{}
\end{fulllineitems}


\end{fulllineitems}



\chapter{Indices and Tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{c}
\item {\sphinxstyleindexentry{common}}\sphinxstyleindexpageref{common:\detokenize{module-common}}
\item {\sphinxstyleindexentry{core}}\sphinxstyleindexpageref{core:\detokenize{module-core}}
\indexspace
\bigletter{f}
\item {\sphinxstyleindexentry{forest}}\sphinxstyleindexpageref{forest:\detokenize{module-forest}}
\indexspace
\bigletter{o}
\item {\sphinxstyleindexentry{opt}}\sphinxstyleindexpageref{opt:\detokenize{module-opt}}
\indexspace
\bigletter{s}
\item {\sphinxstyleindexentry{spatial}}\sphinxstyleindexpageref{spatial:\detokenize{module-spatial}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}